// In: Framework/_Temp/TraceGraph/TraceNode.swift

import AppKit
import Observation

@Observable
final class TraceNode: BaseNode, Layerable {
    let edgeID: GraphEdge.ID
    let graph: TraceGraph
    
    var color: CGColor = NSColor.black.cgColor

    override var isSelectable: Bool { true }
    
    var layerId: UUID? {
        get { graph.edgeMetadata[edgeID]?.layerId }
        set {
            guard let newLayerID = newValue else { return }
            if var metadata = graph.edgeMetadata[edgeID] {
                metadata = TraceEdgeMetadata(width: metadata.width, layerId: newLayerID)
                graph.edgeMetadata[edgeID] = metadata
            }
        }
    }

    init(edgeID: GraphEdge.ID, graph: TraceGraph) {
        self.edgeID = edgeID
        self.graph = graph
        super.init(id: edgeID)
    }
    
    override func hitTest(_ point: CGPoint, tolerance: CGFloat) -> CanvasHitTarget? {
          guard let edge = graph.engine.currentState.edges[edgeID],
                let startV = graph.engine.currentState.vertices[edge.start],
                let endV = graph.engine.currentState.vertices[edge.end],
                let metadata = graph.edgeMetadata[edgeID] else {
              return nil
          }
          
          // 1. Create the centerline path for this segment.
          let centerlinePath = CGMutablePath()
          centerlinePath.move(to: startV.point)
          centerlinePath.addLine(to: endV.point)
          
          // 2. Define the total width of the clickable area.
          // This combines the trace's actual width with the base click tolerance.
          let hitAreaWidth = metadata.width + (tolerance * 2)
          
          // 3. Create a new, temporary path that represents the stroked outline of the centerline.
          // This is the robust, Core Graphics way to define the clickable area.
            let hitPath = centerlinePath.copy(strokingWithWidth: hitAreaWidth, lineCap: .round, lineJoin: .round, miterLimit: 0)
          
          // 4. Ask Core Graphics if the click point is inside this generated shape.
          if hitPath.contains(point) {
              return CanvasHitTarget(node: self, partIdentifier: nil, position: point)
          }
          
          // If the point is not inside the path, it's a miss.
          return nil
      }

    override func makeDrawingPrimitives() -> [DrawingPrimitive] {
        guard let edge = graph.engine.currentState.edges[edgeID],
              let startVertex = graph.engine.currentState.vertices[edge.start],
              let endVertex = graph.engine.currentState.vertices[edge.end] else {
            return []
        }

        let metadata = graph.edgeMetadata[edgeID]
        let width = metadata?.width ?? 1.0

        let path = CGMutablePath()
        path.move(to: startVertex.point)
        path.addLine(to: endVertex.point)

        return [.stroke(
            path: path,
            color: self.color,
            lineWidth: width,
            lineCap: .round
        )]
    }
     
    // --- MODIFIED: This now returns nil to delegate halo drawing to the parent ---
    override func makeHaloPath() -> CGPath? {
        // This node's halo is now generated by its parent, TraceGraphNode,
        // as part of a unified halo. Returning nil prevents it from drawing
        // an individual halo.
        return nil
    }
    
    // --- ADDED: Helper function for hit testing, similar to WireNode ---
    private func isPoint(_ p: CGPoint, onSegmentBetween p1: CGPoint, p2: CGPoint, tolerance: CGFloat) -> Bool {
        let minX = min(p1.x, p2.x) - tolerance, maxX = max(p1.x, p2.x) + tolerance
        let minY = min(p1.y, p2.y) - tolerance, maxY = max(p1.y, p2.y) + tolerance

        guard p.x >= minX && p.x <= maxX && p.y >= minY && p.y <= maxY else { return false }

        let dx = p2.x - p1.x
        let dy = p2.y - p1.y
        
        if hypot(dx, dy) < 1e-6 { // It's a point, not a line
            return hypot(p.x - p1.x, p.y - p1.y) < tolerance
        }

        let distance = abs(dy * p.x - dx * p.y + p2.y * p1.x - p2.x * p1.y) / hypot(dx, dy)
        
        return distance < tolerance
    }
}
