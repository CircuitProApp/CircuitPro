//
//  TextNode.swift
//  CircuitPro
//
//  Created by Giorgi Tchelidze on 8/6/25.
//

import AppKit
import SwiftUI

/// A scene graph node that represents a text element on the canvas.
@Observable
class TextNode: BaseNode {

    // MARK: - Properties

    /// The underlying, persistent data model. This holds style and content *type* information.
    var resolvedText: CircuitText.Resolved {
         didSet {
             // The Resolved type generated by @Resolvable is Equatable.
             guard resolvedText != oldValue else { return }

             parent?.onNeedsRedraw?()
             onNeedsRedraw?()

             if let anchoredself = self as? AnchoredTextNode {
                 anchoredself.commitChanges()
             }
         }
     }
    
    /// The final, generated string to be displayed on the canvas for this render pass.
    /// This property is hydrated by a higher-level manager.
    var displayText: String

    /// Defines the distinct, hittable parts of a TextNode.
    enum Part: Hashable {
        case body
    }

    // MARK: - Overridden Scene Graph Properties

    override var position: CGPoint {
        get { resolvedText.relativePosition }
        set { resolvedText.relativePosition = newValue }
    }

    override var rotation: CGFloat {
        get { resolvedText.cardinalRotation.radians }
        set { resolvedText.cardinalRotation = .closestWithDiagonals(to: newValue) }
    }
    
    // MARK: - Initialization

    init(id: UUID, resolvedText: CircuitText.Resolved, text: String) {
        self.resolvedText = resolvedText
        self.displayText = text // Store the final, hydrated display string.
        super.init(id: id)
        self.isVisible = resolvedText.isVisible
    }

    // MARK: - Path Generation

    private func makeFinalPath() -> CGPath {
        // Use the `displayText` property directly for rendering.
        let untransformedPath = TextUtilities.path(for: self.displayText, font: resolvedText.font.nsFont)
        guard !untransformedPath.isEmpty else { return untransformedPath }

        let targetPoint = resolvedText.anchor.point(in: untransformedPath.boundingBoxOfPath)
        let offset = CGVector(dx: -targetPoint.x, dy: -targetPoint.y)
        var transform = CGAffineTransform(translationX: offset.dx, y: offset.dy)
        return untransformedPath.copy(using: &transform) ?? untransformedPath
     }

     // MARK: - Drawable Conformance

     override func makeDrawingPrimitives() -> [DrawingPrimitive] {
         guard isVisible else { return [] }
         let finalPath = makeFinalPath()
         guard !finalPath.isEmpty else { return [] }
       
         return [.fill(
             path: finalPath,
             color: resolvedText.color.cgColor
         )]
     }
     
     override func makeHaloPath() -> CGPath? {
         guard isVisible else { return nil }
         let finalPath = makeFinalPath()
         guard !finalPath.isEmpty else { return nil }
         
         return finalPath.copy(
             strokingWithWidth: 1.0,
             lineCap: .round,
             lineJoin: .round,
             miterLimit: 1.0
         )
     }

    // MARK: - Hittable Conformance

    override func hitTest(_ point: CGPoint, tolerance: CGFloat) -> CanvasHitTarget? {
        let localPath = makeFinalPath()
        let localBounds = localPath.boundingBoxOfPath

        if localBounds.insetBy(dx: -tolerance, dy: -tolerance).contains(point) {
            return CanvasHitTarget(
                node: self,
                partIdentifier: Part.body,
                position: self.convert(point, to: nil)
            )
        }
        return nil
    }
    
    override var boundingBox: CGRect {
        let path = makeFinalPath()
        let box = path.boundingBoxOfPath
        return box.isNull ? .null : box
     }
}

extension CircuitText.Resolved: Equatable {
    static func == (lhs: CircuitText.Resolved, rhs: CircuitText.Resolved) -> Bool {
        return lhs.id == rhs.id
    }
    
    
}
