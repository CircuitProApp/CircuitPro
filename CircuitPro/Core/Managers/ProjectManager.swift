//
//  ProjectManager.swift
//  Circuit Pro
//
//  Created by Giorgi Tchelidze on 4/5/25.
//

import SwiftUI
import Observation

@Observable
final class ProjectManager {
    
    var project: CircuitProject
    var selectedDesign: CircuitDesign?
    var selectedNodeIDs: Set<UUID> = []
    var canvasNodes: [BaseNode] = []
    var selectedNetIDs: Set<UUID> = []
    
    var schematicGraph = WireGraph()
    
    init(
        project: CircuitProject,
        selectedDesign: CircuitDesign? = nil
    ) {
        self.project        = project
        self.selectedDesign = selectedDesign
    }
    
    var componentInstances: [ComponentInstance] {
        get { selectedDesign?.componentInstances ?? [] }
        set { selectedDesign?.componentInstances = newValue }
    }
    
    func persistSchematicGraph() {
        guard selectedDesign != nil else { return }
        selectedDesign?.wires = schematicGraph.toWires()
    }
    
    // MARK: - New, Simplified Property Management
    
    /// Updates a component's property using an edited `Resolved` model.
    /// This method delegates the entire update operation to the component itself.
    func updateProperty(for component: ComponentInstance, with editedProperty: Property.Resolved) {
        component.apply(editedProperty)
        rebuildCanvasNodes()
    }
    
    /// Adds a new, ad-hoc property directly to a component instance.
    func addProperty(_ newProperty: Property.Instance, to component: ComponentInstance) {
        component.add(newProperty)
        rebuildCanvasNodes()
    }
    
    /// Removes a property from a component.
    /// This will either delete an ad-hoc instance or revert a definition-based property to its default.
    func removeProperty(_ propertyToRemove: Property.Resolved, from component: ComponentInstance) {
        component.remove(propertyToRemove)
        rebuildCanvasNodes()
    }

    // MARK: - Text Management (Remains for now, will be refactored next)
    
    func toggleDynamicTextVisibility(for component: ComponentInstance, source: TextSource) {
        // The .resolvedCircuitTexts property is generated by @ResolvableDestination
        // and gives us a live, resolved view of all texts.
        if let textToToggle = component.symbolInstance.resolvedItems.first(where: { $0.contentSource == source }) {
            // Found an existing text (either from a definition or an instance).
            // We create a mutable copy, change the visibility, and apply it back.
            var editedText = textToToggle
            editedText.isVisible.toggle()
            
            // Use our new, clean update function.
            updateText(for: component, with: editedText)
            
        } else {
            // The text does not exist yet. This means it's a definition-based text
            // that has never been overridden, and we want to add it for the first time
            // (e.g., a value or name that was hidden by default).
            // Or, it could be a completely new ad-hoc text. For visibility toggling,
            // we'll assume the primary case is adding a new instance.
            
            // This logic is for creating a brand new instance if one doesn't exist.
            let existingTextPositions = component.symbolInstance.resolvedItems.map(\.relativePosition)
            let lowestY = existingTextPositions.map(\.y).min() ?? -20
            let newPosition = CGPoint(x: 0, y: lowestY - 10)
            
            let newTextInstance = CircuitText.Instance(
                contentSource: source,
                relativePosition: newPosition,
                anchorPosition: newPosition
                // other properties will use their default values
            )
            
            addText(newTextInstance, to: component)
        }
    }
    
    func togglePropertyVisibility(for component: ComponentInstance, property: Property.Resolved) {
        guard case .definition(let propertyDef) = property.source else {
            print("Error: Visibility can only be toggled for definition-based properties.")
            return
        }
        let source = TextSource.componentProperty(definitionID: propertyDef.id)
        toggleDynamicTextVisibility(for: component, source: source)
    }

    // MARK: - Other Component Actions
    
    func updateReferenceDesignator(for component: ComponentInstance, newIndex: Int) {
        component.referenceDesignatorIndex = newIndex
        rebuildCanvasNodes()
    }
    
    // MARK: - Canvas and Graph Management
    
    private func makeGraph(from design: CircuitDesign) -> WireGraph {
        let newGraph = WireGraph()
        newGraph.build(from: design.wires)
        
        for inst in design.componentInstances {
            guard let symbolDef = inst.definition?.symbol else { continue }
            newGraph.syncPins(for: inst.symbolInstance, of: symbolDef, ownerID: inst.id)
        }
        return newGraph
    }
    
    func rebuildCanvasNodes() {
        guard let design = selectedDesign else {
            self.canvasNodes = []
            self.schematicGraph = WireGraph()
            return
        }
        
        let newGraph = self.makeGraph(from: design)
        self.schematicGraph = newGraph
        
        let symbolNodes: [SymbolNode] = design.componentInstances.compactMap { inst -> SymbolNode? in
            guard inst.symbolInstance.definition != nil else { return nil }
            
            // 1. Get the resolved text objects with style properties.
            let resolvedTextsWithStyle = inst.symbolInstance.resolvedItems
            
            // 2. --- THIS IS THE FIX ---
            //    Map over them to populate the `.text` content string.
            let fullyResolvedTexts = resolvedTextsWithStyle.map { resolvedText -> CircuitText.Resolved in
                var hydratedText = resolvedText
                hydratedText.text = self.generateString(for: resolvedText.contentSource, component: inst)
                return hydratedText
            }
            
            // 3. Pass the fully populated models to the node.
            return SymbolNode(id: inst.id, instance: inst.symbolInstance, resolvedTexts: fullyResolvedTexts, graph: self.schematicGraph)
        }
        let graphNode = SchematicGraphNode(graph: self.schematicGraph)
        graphNode.syncChildNodesFromModel()
        
        self.canvasNodes = symbolNodes + [graphNode]
    }

    func upsertSymbolNode(for inst: ComponentInstance) {
        guard inst.symbolInstance.definition != nil else { return }
        
        let resolvedTextsWithStyle = inst.symbolInstance.resolvedItems
        let fullyResolvedTexts = resolvedTextsWithStyle.map { resolvedText -> CircuitText.Resolved in
            var hydratedText = resolvedText
            hydratedText.text = self.generateString(for: resolvedText.contentSource, component: inst)
            return hydratedText
        }
        
        // --- UPDATED LINE ---
        guard let node = SymbolNode(id: inst.id, instance: inst.symbolInstance, resolvedTexts: inst.symbolInstance.resolvedItems, graph: self.schematicGraph) else { return }
        
        if let idx = canvasNodes.firstIndex(where: { $0.id == inst.id }) {
            canvasNodes[idx] = node
        } else if let graphIndex = canvasNodes.firstIndex(where: { $0 is SchematicGraphNode }) {
            canvasNodes.insert(node, at: graphIndex)
        } else {
            let graphNode = SchematicGraphNode(graph: self.schematicGraph)
            graphNode.syncChildNodesFromModel()
            canvasNodes = [node, graphNode]
        }
    }
    
    func updateText(for component: ComponentInstance, with editedText: CircuitText.Resolved) {
        component.apply(editedText)
        rebuildCanvasNodes()
    }

    /// Adds a new, ad-hoc text directly to a component instance.
    func addText(_ newText: CircuitText.Instance, to component: ComponentInstance) {
        component.add(newText)
        rebuildCanvasNodes()
    }

    /// Removes a text from a component.
    /// This will either delete an ad-hoc instance or revert a definition-based text to its default style.
    func removeText(_ textToRemove: CircuitText.Resolved, from component: ComponentInstance) {
        component.remove(textToRemove)
        rebuildCanvasNodes()
    }
    
    func generateString(for source: TextSource, component: ComponentInstance) -> String {
        switch source {
        case .componentName:
            // Assumes ComponentDefinition has a 'name' property
            return component.definition?.name ?? "???"
            
        case .componentReferenceDesignator:
            return component.referenceDesignatorIndex.description
            
        case .componentProperty(let definitionID):
            // Find the property and format it
            if let property = component.displayedProperties.first(where: { $0.id == definitionID }),
               let resolvedText = component.symbolInstance.resolvedItems.first(where: { $0.contentSource == source }) {
                
                // This is a simplified example. You'll build the string
                // based on the resolvedText.displayOptions (showKey, showValue, showUnit)
                var parts: [String] = []
                if resolvedText.displayOptions.showKey {
                    parts.append(property.key.label)
                }
                if resolvedText.displayOptions.showValue {
                    parts.append(property.value.description)
                }
                if resolvedText.displayOptions.showUnit {
                    parts.append(property.unit.description)
                }
                return parts.joined(separator: " ")
            }
            return "" // Return empty if property isn't found
            
        }
    }
}


extension ComponentInstance {
    /// Applies changes from a resolved text model back to the appropriate
    /// override or instance.
    func apply(_ editedText: CircuitText.Resolved) {
        // The .apply(newValue:) method is automatically generated
        // by the @ResolvableDestination macro on SymbolInstance.
        symbolInstance.apply(editedText)
    }

    /// Adds a new, ad-hoc text instance.
    func add(_ newInstance: CircuitText.Instance) {
        // The .add(newInstance:) method is also generated.
        symbolInstance.add(newInstance)
    }

    /// Removes a text by deleting its override or instance.
    func remove(_ textToRemove: CircuitText.Resolved) {
        // The .remove(resolvedValue:) method is also generated.
        symbolInstance.remove(textToRemove)
    }
}
