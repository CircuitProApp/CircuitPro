//
//  CircleHandles.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/22/25.
//
import SwiftUI

struct CircleHandles: View {
  var circle: CirclePrimitive
  var update: (CirclePrimitive) -> Void
  let size: CGFloat = 10
  
  @State private var direction: CGVector = .init(dx: 1, dy: 0)

  // Offset for the radius handle
  private var handleOffset: CGSize {
    CGSize(
      width: direction.dx * circle.radius,
      height: direction.dy * circle.radius
    )
  }

  var body: some View {
    ZStack {
      // Center handle marker
      Circle()
            .fill(.blue)
        .frame(width: size, height: size)
        // static center point

      // Radius handle
      Circle()
        .fill(Color.white)
        .overlay(Circle().stroke(Color.blue, lineWidth: 2))
        .frame(width: size, height: size)
        .offset(handleOffset)
        .gesture(
          DragGesture()
            .onChanged { value in
              let dx = value.location.x
              let dy = value.location.y
              let dist = max(1, hypot(dx, dy))

              // update direction and radius
              direction = CGVector(dx: dx / dist, dy: dy / dist)
              var updated = circle
              updated.radius = dist
              update(updated)
            }
        )
    }
  }
}
//
//  LineHandles.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/22/25.
//
import SwiftUI



struct LineHandles: View {
  var line: LinePrimitive
  var update: (LinePrimitive) -> Void
  let size: CGFloat = 10

  var body: some View {
    ZStack {
      Circle()
        .fill(Color.white)
        .overlay(Circle().stroke(Color.blue, lineWidth: 2))
        .frame(width: size, height: size)
        .position(line.start)
        .gesture(
          DragGesture()
            .onChanged { value in
              var updated = line
              updated.start = value.location
              update(updated)
            }
        )

      Circle()
        .fill(Color.white)
        .overlay(Circle().stroke(Color.blue, lineWidth: 2))
        .frame(width: size, height: size)
        .position(line.end)
        .gesture(
          DragGesture()
            .onChanged { value in
              var updated = line
              updated.end = value.location
              update(updated)
            }
        )
    }
  }
}
//
//  RectangleHandles.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/22/25.
//
import SwiftUI
struct RectangleHandles: View {
  var rect: RectanglePrimitive
  var update: (RectanglePrimitive) -> Void
  let size: CGFloat = 10   // your larger, easier‑to‑grab handle

  // Each corner’s direction from center (dx, dy ∈ {‑1, +1})
  private let cornerDirs: [CGVector] = [
    CGVector(dx: -1, dy: -1), // top‑left
    CGVector(dx:  1, dy: -1), // top‑right
    CGVector(dx: -1, dy:  1), // bottom‑left
    CGVector(dx:  1, dy:  1)  // bottom‑right
  ]

  // Freeze the state at drag start
  @State private var startRect: RectanglePrimitive?
  @State private var activeDir: CGVector?

  var body: some View {
    ZStack {
      ForEach(cornerDirs, id: \.self) { dir in
        Circle()
          .fill(Color.white)
          .overlay(Circle().stroke(Color.green, lineWidth: 2))
          .frame(width: size, height: size)
          // place handle at the correct corner in local coords
          .offset(
            x: dir.dx * rect.size.width  / 2,
            y: dir.dy * rect.size.height / 2
          )
          .highPriorityGesture(
            DragGesture()
              .onChanged { value in
                // 1️⃣ On first drag update, capture the starting rect and which corner
                if startRect == nil {
                  startRect = rect
                  activeDir = dir
                }
                guard
                  let original = startRect,
                  let d = activeDir
                else { return }

                // 2️⃣ Compute original corner positions in LOCAL coords
                let halfW = original.size.width  / 2
                let halfH = original.size.height / 2
                let moving = CGPoint(x:  d.dx * halfW,
                                     y:  d.dy * halfH)
                let fixed  = CGPoint(x: -d.dx * halfW,
                                     y: -d.dy * halfH)

                // 3️⃣ Apply the gesture’s translation to the moving corner
                let newMoving = CGPoint(
                  x: moving.x + value.translation.width,
                  y: moving.y + value.translation.height
                )

                // 4️⃣ Build the new rectangle in LOCAL space
                let minX = min(newMoving.x, fixed.x)
                let maxX = max(newMoving.x, fixed.x)
                let minY = min(newMoving.y, fixed.y)
                let maxY = max(newMoving.y, fixed.y)

                let newWidth  = max(1, maxX - minX)
                let newHeight = max(1, maxY - minY)
                let localCenter = CGPoint(
                  x: (minX + maxX) / 2,
                  y: (minY + maxY) / 2
                )

                // 5️⃣ Convert local center back to GLOBAL coords:
                //    original.position is the old global center
                let globalCenter = CGPoint(
                  x: original.position.x + localCenter.x,
                  y: original.position.y + localCenter.y
                )

                // 6️⃣ Write back to the primitive
                var updated = original
                updated.position = globalCenter
                updated.size     = CGSize(width: newWidth,
                                          height: newHeight)
                update(updated)
              }
              .onEnded { _ in
                // reset for next drag
                startRect = nil
                activeDir = nil
              }
          )
      }
    }
    // ← NO .position or .offset here!  renderFullView() already moves this ZStack
  }
}
//
//  LineHandles.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/22/25.
//
import SwiftUI


extension GraphicPrimitiveType {
  @ViewBuilder
  static func handles(for binding: Binding<GraphicPrimitiveType>) -> some View {
    switch binding.wrappedValue {
    case .line(let line):
      LineHandles(line: line) { new in
        binding.wrappedValue = .line(new)
      }

    case .rectangle(let rect):
      RectangleHandles(rect: rect) { new in
        binding.wrappedValue = .rectangle(new)
      }

    case .circle(let circle):
      CircleHandles(circle: circle) { new in
        binding.wrappedValue = .circle(new)
      }

    case .arc:
      EmptyView()
    }
  }
}
//
//  LineShape.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/16/25.
//


import SwiftUI

// MARK: - Custom Shape Structs

struct LineShape: Shape {
    var start: CGPoint
    var end: CGPoint

    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.move(to: start)
        path.addLine(to: end)
        
        return path
    }
}//
//  ArcShape.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/16/25.
//


import SwiftUI



struct ArcShape: Shape {
    var radius: CGFloat
    var startAngle: Angle
    var endAngle: Angle
    var clockwise: Bool

    func path(in rect: CGRect) -> Path {
        var path = Path()
        path.addArc(center: .zero,
                    radius: radius,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    clockwise: clockwise)
        return path
    }
}
//
//  CirclePrimitive.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/12/25.
//
import SwiftUI

struct CirclePrimitive: GraphicPrimitive {
    var id = UUID()
    var position: CGPoint
    var strokeWidth: CGFloat
    var color: SDColor
    var filled: Bool

    var radius: CGFloat
}
//
//  GraphicPrimitive.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/20/25.
//
import SwiftUI

protocol GraphicPrimitive: Identifiable, Hashable, Codable {
    var id: UUID { get }
    var position: CGPoint { get set }
    var strokeWidth: CGFloat { get set }
    var color: SDColor { get set }
    var filled: Bool { get set }
}
//
//  RectanglePrimitive.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/12/25.
//
import SwiftUI

struct RectanglePrimitive: GraphicPrimitive {
    var id = UUID()
    var position: CGPoint
    var strokeWidth: CGFloat
    var color: SDColor
    var filled: Bool

    var size: CGSize
    var cornerRadius: CGFloat
}
//
//  Line.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/12/25.
//

import SwiftUI

struct LinePrimitive: GraphicPrimitive {
    var id = UUID()
  
    var strokeWidth: CGFloat
    var color: SDColor
    var filled: Bool = false 

    var start: CGPoint
    var end: CGPoint
    
    var position: CGPoint {
         get {
             CGPoint(x: (start.x + end.x) / 2, y: (start.y + end.y) / 2)
         }
         set {
             // Calculate the vector needed to move the current midpoint to the new position (newValue)
             let currentMidpoint = CGPoint(x: (start.x + end.x) / 2, y: (start.y + end.y) / 2)
             let dx = newValue.x - currentMidpoint.x
             let dy = newValue.y - currentMidpoint.y

             // Apply this vector to both start and end points to translate the line
             start = CGPoint(x: start.x + dx, y: start.y + dy)
             end = CGPoint(x: end.x + dx, y: end.y + dy)
         }
     }
}
//
//  ArcPrimitive.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/12/25.
//

import SwiftUI

struct ArcPrimitive: GraphicPrimitive {
    var id = UUID()
    var position: CGPoint
    var strokeWidth: CGFloat
    var color: SDColor
    var filled: Bool = false // Optional: make pie later

    var radius: CGFloat
    var startAngle: CGFloat
    var endAngle: CGFloat
    var clockwise: Bool
}
//
//  Highlight.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/22/25.
//
import SwiftUI


extension GraphicPrimitiveType {
  @ViewBuilder
  func highlightBackground() -> some View {
    switch self {
    case .line(let l):
      LineShape(start: l.start, end: l.end)
            .stroke(l.color.color.opacity(0.3), style: StrokeStyle(lineWidth: l.strokeWidth + 5, lineCap: .round))

    case .rectangle(let r):
      RoundedRectangle(cornerRadius: r.cornerRadius)
            .stroke(r.color.color.opacity(0.3), style: StrokeStyle(lineWidth: r.strokeWidth + 5, lineJoin: .round))

        .frame(width: r.size.width, height: r.size.height)

    case .circle(let c):
      Circle()
        .stroke(c.color.color.opacity(0.3), lineWidth: c.strokeWidth + 5)
        .frame(width: c.radius * 2, height: c.radius * 2)

    case .arc(let a):
      ArcShape(
        radius: a.radius,
        startAngle: .degrees(a.startAngle),
        endAngle: .degrees(a.endAngle),
        clockwise: a.clockwise
      )
      .stroke(a.color.color.opacity(0.3), lineWidth: a.strokeWidth + 5)
    }
  }
}
//
//  Render.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/22/25.
//
import SwiftUI

extension GraphicPrimitiveType {
  @ViewBuilder
  func render() -> some View {
    switch self {
    case .line(let l):
      LineShape(start: l.start, end: l.end)
            .stroke(l.color.color, style: StrokeStyle(lineWidth: l.strokeWidth, lineCap: .round))


    case .rectangle(let r):
      RoundedRectangle(cornerRadius: r.cornerRadius)
            .stroke(r.color.color, lineWidth: r.strokeWidth)
            .frame(width: r.size.width, height: r.size.height)
        
            .background(r.filled ? RoundedRectangle(cornerRadius: r.cornerRadius).fill(r.color.color) : nil)


    case .circle(let c):
      Circle()
            .stroke(c.color.color, lineWidth: c.strokeWidth)
        .frame(width: c.radius*2, height: c.radius*2)
        .background(c.filled ? Circle().fill(c.color.color) : nil)


    case .arc(let a):
      ArcShape(radius:    a.radius,
               startAngle:.degrees(a.startAngle),
               endAngle:  .degrees(a.endAngle),
               clockwise: a.clockwise)
      .stroke(a.color.color, lineWidth: a.strokeWidth)
    }
  }
}
//
//  RenderFull.swift
//  Electron
//
//  Created by Giorgi Tchelidze on 4/22/25.
//
import SwiftUI




extension GraphicPrimitiveType {
  @ViewBuilder
  func renderFullView(
    isSelected: Bool,
    binding: Binding<GraphicPrimitiveType>,
    dragOffset: CGSize,
    opacity: Double
  ) -> some View {
    ZStack {
      render()               // draw the shape at (0,0)
      if isSelected {
        highlightBackground()
        Self.handles(for: binding)  // draws handle(s) positioned via offset
      }
    }
    // ← here we move the *entire* ZStack to its real on‑canvas position
    .if(!self.isLine) { $0.position(self.position) }
    .offset(dragOffset)
    .opacity(opacity)
  }
}


import SwiftUI

enum GraphicPrimitiveType: Codable, Hashable, Identifiable {
    case line(LinePrimitive)
    case rectangle(RectanglePrimitive)
    case circle(CirclePrimitive)
    case arc(ArcPrimitive)

    var id: UUID {
        switch self {
        case .line(let l): return l.id
        case .rectangle(let r): return r.id
        case .circle(let c): return c.id
        case .arc(let a): return a.id
        }
    }
    
    

    var base: any GraphicPrimitive {
        switch self {
        case .line(let l): return l
        case .rectangle(let r): return r
        case .circle(let c): return c
        case .arc(let a): return a
        }
    }
}


extension GraphicPrimitiveType {
    func cgPath(for symbolCenter: CGPoint) -> CGPath {
        switch self {
        case .line(let line):
            let p1 = CGPoint(x: symbolCenter.x + line.start.x, y: symbolCenter.y + line.start.y)
            let p2 = CGPoint(x: symbolCenter.x + line.end.x, y: symbolCenter.y + line.end.y)
            let mutablePath = CGMutablePath()
            mutablePath.move(to: p1)
            mutablePath.addLine(to: p2)
            return mutablePath
            
        case .rectangle(let rect):
            // The rectangle’s center is symbolCenter offset by rect.position.
            let center = CGPoint(x: symbolCenter.x + rect.position.x, y: symbolCenter.y + rect.position.y)
            let frame = CGRect(x: center.x - rect.size.width / 2,
                               y: center.y - rect.size.height / 2,
                               width: rect.size.width,
                               height: rect.size.height)
            return CGPath(roundedRect: frame, cornerWidth: rect.cornerRadius, cornerHeight: rect.cornerRadius, transform: nil)
            
        case .circle(let circle):
            let center = CGPoint(x: symbolCenter.x + circle.position.x, y: symbolCenter.y + circle.position.y)
            let mutablePath = CGMutablePath()
            mutablePath.addArc(center: center,
                               radius: circle.radius,
                               startAngle: 0,
                               endAngle: CGFloat.pi * 2,
                               clockwise: false)
            return mutablePath
            
        case .arc(let arc):
            let center = CGPoint(x: symbolCenter.x + arc.position.x, y: symbolCenter.y + arc.position.y)
            let mutablePath = CGMutablePath()
            mutablePath.addArc(center: center,
                               radius: arc.radius,
                               startAngle: arc.startAngle.radians,
                               endAngle: arc.endAngle.radians,
                               clockwise: arc.clockwise)

            return mutablePath
        }
    }
    
    /// Uses the system-optimized CGPath hit testing.
    /// If the primitive is filled, it tests against the fill region; otherwise, it tests against a stroked version of the path.
    func systemHitTest(at point: CGPoint, symbolCenter: CGPoint, tolerance: CGFloat = 5.0) -> Bool {
        let basePath = self.cgPath(for: symbolCenter)
        
        // For filled shapes (like filled polygons or rectangles), test the fill area.
        if self.isFilled() {
            return basePath.contains(point)
        } else {
            // For non-filled shapes, generate a stroked path that reflects the visible stroke.
            // This creates a new CGPath that represents the “painted” area.
            let effectiveStrokeWidth = self.strokeWidthWithTolerance(tolerance: tolerance)
            
            let strokedPath = basePath.copy(strokingWithWidth: effectiveStrokeWidth,
                                                  lineCap: .butt,
                                                  lineJoin: .miter,
                                                  miterLimit: 10) 
            return strokedPath.contains(point)
        }
    }
    
    // Helper to determine if a primitive is to be considered filled.
    func isFilled() -> Bool {
        switch self {
        case .line:
            return false
        case .rectangle(let r):
            return r.filled
        case .circle(let c):
            return c.filled
        case .arc(let a):
            return a.filled
        }
    }
    
    // Helper to compute effective stroke width including tolerance.
    func strokeWidthWithTolerance(tolerance: CGFloat = 5.0) -> CGFloat {
        switch self {
        case .line(let l):
            return l.strokeWidth + tolerance
        case .rectangle(let r):
            return r.strokeWidth + tolerance
        case .circle(let c):
            return c.strokeWidth + tolerance
        case .arc(let a):
            return a.strokeWidth + tolerance
        }
    }
}




extension GraphicPrimitiveType {
  var position: CGPoint {
    get {
      switch self {
      case .line(let l):       return l.position
      case .rectangle(let r):  return r.position
      case .circle(let c):     return c.position
      case .arc(let a):        return a.position
      }
    }
    mutating set {
      switch self {
      case .line(var l):
        let dx = newValue.x - l.position.x
        let dy = newValue.y - l.position.y
        l.start.x += dx; l.start.y += dy
        l.end.x   += dx; l.end.y   += dy
        l.position = newValue
        self = .line(l)

      case .rectangle(var r):
        r.position = newValue
        self = .rectangle(r)

      case .circle(var c):
        c.position = newValue
        self = .circle(c)

      case .arc(var a):
        a.position = newValue
        self = .arc(a)
      }
    }
  }
}

extension GraphicPrimitiveType {
  var isLine: Bool {
    if case .line = self { return true }
    return false
  }
}



extension GraphicPrimitiveType {
  mutating func setLine(_ line: LinePrimitive) {
    self = .line(line)
  }

  mutating func setRectangle(_ rect: RectanglePrimitive) {
    self = .rectangle(rect)
  }

  mutating func setCircle(_ circle: CirclePrimitive) {
    self = .circle(circle)
  }

  mutating func setArc(_ arc: ArcPrimitive) {
    self = .arc(arc)
  }
}

