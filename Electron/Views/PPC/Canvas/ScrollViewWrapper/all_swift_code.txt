
//  AdvancedScrollView.swift
import SwiftUI


public struct AdvancedScrollView<Content: View>: View {
    // Access the shared model via EnvironmentObject
    @Environment(\.scrollViewManager) var manager
    
    public let magnificationRange: ClosedRange<CGFloat>
    
    let content: () -> Content // Content closure no longer takes proxy directly
    
    // Public initializer with default values
    public init(magnificationRange: ClosedRange<CGFloat> = (0.5...2.0),
                isScrollIndicatorVisible: Bool = true,
                @ViewBuilder content: @escaping () -> Content) {
        self.init(magnificationRange: magnificationRange,
                  tapContentGestureInfo: nil,
                  dragContentGestureInfo: nil,
                  content: content)
    }
    
    // Internal initializer with gesture info
    init(magnificationRange: ClosedRange<CGFloat>,
         tapContentGestureInfo: TapContentGestureInfo?,
         dragContentGestureInfo: DragContentGestureInfo?,
         @ViewBuilder content: @escaping () -> Content) {
        self.magnificationRange = magnificationRange
        self.tapContentGestureInfo = tapContentGestureInfo
        self.dragContentGestureInfo = dragContentGestureInfo
        self.content = content
    }
    
    public var body: some View {
        NSScrollViewRepresentable(manager: manager,
                                  magnificationRange: magnificationRange,
                                  tapContentGestureInfo: tapContentGestureInfo,
                                  dragContentGestureInfo: dragContentGestureInfo,
                                  content: content)
    }
    
    // Private properties for gesture info
    var tapContentGestureInfo: TapContentGestureInfo?
    var dragContentGestureInfo: DragContentGestureInfo?
}
//EOF

//  NSScrollViewRepresentable.swift

import AppKit
import SwiftUI

struct NSScrollViewRepresentable<Content: View>: NSViewRepresentable {
    let manager: ScrollViewManager
    let magnificationRange: ClosedRange<CGFloat>
    let tapContentGestureInfo: TapContentGestureInfo?
    let dragContentGestureInfo: DragContentGestureInfo?
    let content: () -> Content // Content closure no longer takes proxy
    
    // MARK: - Coordinator
    class Coordinator: NSObject, NSGestureRecognizerDelegate {
        var parent: NSScrollViewRepresentable
        
        init(parent: NSScrollViewRepresentable) {
            self.parent = parent
        }
        
        // MARK: - Tap Gesture Handler
        @objc func handleTapGesture(_ gesture: NSClickGestureRecognizer) {
            guard let action = parent.tapContentGestureInfo?.action,
                  let scrollView = gesture.view?.superview as? NSScrollViewSubclass,
                  let documentView = scrollView.documentView,
                  let proxy = parent.manager.proxy else { return }
            let location = gesture.location(in: documentView)
            action(location, proxy)
        }
        
        // MARK: - Pan Gesture Handler
        @objc func handlePanGesture(_ gesture: NSAutoscrollPanGestureRecognizer) {
            guard let action = parent.dragContentGestureInfo?.action,
                  let scrollView = gesture.view?.superview as? NSScrollViewSubclass,
                  let documentView = scrollView.documentView,
                  let phase = ContinuousGesturePhase(gesture.state),
                  let proxy = parent.manager.proxy else { return }
            let location = gesture.location(in: documentView)
            let translation = gesture.translation(in: documentView)
            _ = action(phase, location, CGSize(width: translation.x, height: translation.y), proxy)
        }
        
        // MARK: - Gesture Recognizer Delegate
        func gestureRecognizerShouldBegin(_ gestureRecognizer: NSGestureRecognizer) -> Bool {
            if let panGesture = gestureRecognizer as? NSPanGestureRecognizer,
               let scrollView = panGesture.view?.superview as? NSScrollViewSubclass,
               let documentView = scrollView.documentView,
               let action = parent.dragContentGestureInfo?.action,
               let proxy = parent.manager.proxy {
                let location = gestureRecognizer.location(in: documentView)
                let translationPoint = panGesture.translation(in: documentView)
                let translationSize = CGSize(width: translationPoint.x, height: translationPoint.y)
                return action(.possible, location, translationSize, proxy)
            }
            return true
        }
    }
    
    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }
    
    // MARK: - NSViewRepresentable Methods
    func makeNSView(context: Context) -> NSScrollViewSubclass {
        
        let scrollView = NSScrollViewSubclass()
        scrollView.minMagnification = magnificationRange.lowerBound
        scrollView.maxMagnification = magnificationRange.upperBound
        scrollView.hasHorizontalScroller = true
        scrollView.hasVerticalScroller = true
        scrollView.allowsMagnification = true
        scrollView.contentView = NSClipView()
        
        setupTapGesture(for: scrollView, coordinator: context.coordinator)
        setupPanGesture(for: scrollView, coordinator: context.coordinator)
        
        return scrollView
    }
    
    func updateNSView(_ nsView: NSScrollViewSubclass, context: Context) {
        let proxy = makeProxy(for: nsView)
        manager.proxy = proxy // Set the proxy in the model
        let contentView = content()
        
        if let hostingView = nsView.documentView as? NSHostingView<AnyView> {
            hostingView.rootView = AnyView(contentView)
        } else {
            nsView.documentView = NSHostingView(rootView: AnyView(contentView))
        }
        nsView.documentView?.frame = CGRect(
            origin: .zero,
            size: nsView.documentView?.fittingSize ?? .zero
        )
    }
    
    // MARK: - Helper to Create Proxy
    fileprivate func makeProxy(for scrollView: NSScrollViewSubclass) -> AdvancedScrollViewProxy {
        var proxy = AdvancedScrollViewProxy()
        
        proxy.getContentOffset = {
            scrollView.contentView.bounds.origin
        }
        
        proxy.setContentOffset = { offset in
            let point = scrollView.contentView.convert(offset, to: scrollView.documentView)
            scrollView.documentView?.scroll(point)
        }
        
        proxy.getContentSize = {
            scrollView.documentView?.bounds.size ?? .zero
        }
        
        proxy.getContentInset = {
            EdgeInsets(scrollView.contentInsets)
        }
        
        proxy.setContentInset = {
            scrollView.contentInsets = NSEdgeInsets($0)
        }
        
        proxy.getVisibleRect = {
            scrollView.documentVisibleRect
        }
        
        proxy.getScrollerInsets = {
            EdgeInsets(scrollView.scrollerInsets)
        }
        
        proxy.getMagnification = {
            scrollView.magnification
        }
        
        proxy.setMagnification = { newMagnification in
            let minMag = scrollView.minMagnification
            let maxMag = scrollView.maxMagnification
            let boundedValue = min(max(newMagnification, minMag), maxMag)
            scrollView.magnification = boundedValue
        }
        
        proxy.getIsLiveMagnify = {
            scrollView.isLiveMagnify
        }
        
        proxy.getIsAutoscrollEnabled = {
            scrollView.isAutoscrollEnabled
        }
        
        proxy.setIsAutoscrollEnabled = {
            scrollView.isAutoscrollEnabled = $0
        }
        
        return proxy
    }
}



//EOF

//  Managers.swift

import SwiftUI
import Observation

@Observable
class ScrollViewManager {
    var proxy: AdvancedScrollViewProxy?
}


private struct ScrollViewManagerKey: EnvironmentKey {
    static let defaultValue: ScrollViewManager = ScrollViewManager()
}

extension EnvironmentValues {
    var scrollViewManager: ScrollViewManager {
        get { self[ScrollViewManagerKey.self] }
        set { self[ScrollViewManagerKey.self] = newValue }
    }
}

//EOF

//  NSScrollViewSubclass.swift

import AppKit
import SwiftUI

final class NSScrollViewSubclass: NSScrollView {
    
    private var liveMagnifyTask: Task<Void, Never>?
    private var endMagnifyTask: Task<Void, Never>?

    private(set) var isLiveMagnify: Bool = false
    var isAutoscrollEnabled: Bool = true

    override init(frame frameRect: NSRect) {
        super.init(frame: frameRect)
        
        liveMagnifyTask = Task { [weak self] in
            guard let self = self else { return }
            for await _ in NotificationCenter.default.notifications(
                named: NSScrollView.willStartLiveMagnifyNotification,
                object: self
            ) {
                self.isLiveMagnify = true
            }
        }
        
        endMagnifyTask = Task { [weak self] in
            guard let self = self else { return }
            for await _ in NotificationCenter.default.notifications(
                named: NSScrollView.didEndLiveMagnifyNotification,
                object: self
            ) {
                self.isLiveMagnify = false
            }
        }
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    deinit {
        liveMagnifyTask?.cancel()
        endMagnifyTask?.cancel()
    }
}

final class NSClipViewSubclass: NSClipView {}


final class NSHostingViewSubclass<Content: View>: NSHostingView<Content> {}

//EOF

//  Misc.swift
import SwiftUI
import AppKit

extension EdgeInsets {
    init(_ nsEdgeInsets: NSEdgeInsets) {
        self.init(top: nsEdgeInsets.top,
                  leading: nsEdgeInsets.left,
                  bottom: nsEdgeInsets.bottom,
                  trailing: nsEdgeInsets.right)
    }
}

extension NSEdgeInsets {
    init(_ edgeInsets: EdgeInsets) {
        self.init(top: edgeInsets.top,
                  left: edgeInsets.leading,
                  bottom: edgeInsets.bottom,
                  right: edgeInsets.trailing)
    }
}

//EOF

//  NSAutoscrollPanGestureRecognizer.swift

import AppKit

/// NSPanGestureRecognizer subclass that keeps track of last mouse dragged event to use in autoscroll(with:) method.
final class NSAutoscrollPanGestureRecognizer: NSPanGestureRecognizer {

    private(set) var mouseDraggedEvent: NSEvent?

    override func mouseDragged(with event: NSEvent) {
        super.mouseDragged(with: event)
        mouseDraggedEvent = event
    }

    /// Offset to add to translation. Reset to `.zero` when gesture resets.
    var translationOffset: NSPoint = .zero

    override func translation(in view: NSView?) -> NSPoint {
        super.translation(in: view) + translationOffset
    }

    /// Indicates whether the user is selecting content, to enable autoscroll.
    var isContentSelected: Bool = false

    override func reset() {
        super.reset()
        mouseDraggedEvent = nil
        translationOffset = .zero
        isContentSelected = false
    }
}
//EOF


//  AdvancedScrollView+Gestures.swift
import SwiftUI

struct TapContentGestureInfo {
    var count: Int
    var action: TapContentAction
}

struct DragContentGestureInfo {
    var action: DragContentAction
}

public typealias TapContentAction = (_ location: CGPoint, _ proxy: AdvancedScrollViewProxy) -> Void

public typealias DragContentAction = (_ phase: ContinuousGesturePhase, _ location: CGPoint, _ translation: CGSize, _ proxy: AdvancedScrollViewProxy) -> Bool

public extension AdvancedScrollView {
    func onTapContentGesture(count: Int = 1, perform action: @escaping TapContentAction) -> AdvancedScrollView {
        let tapContentGestureInfo = TapContentGestureInfo(count: count, action: action)
        return AdvancedScrollView(magnificationRange: magnificationRange,
                                 
                                  tapContentGestureInfo: tapContentGestureInfo,
                                  dragContentGestureInfo: dragContentGestureInfo,
                                  content: content)
    }

    func onDragContentGesture(perform action: @escaping DragContentAction) -> AdvancedScrollView {
        let dragContentGestureInfo = DragContentGestureInfo(action: action)
        return AdvancedScrollView(magnificationRange: magnificationRange,
                                 
                                  tapContentGestureInfo: tapContentGestureInfo,
                                  dragContentGestureInfo: dragContentGestureInfo,
                                  content: content)
    }
}

extension NSScrollViewRepresentable {
     func setupTapGesture(for scrollView: NSScrollViewSubclass, coordinator: Coordinator) {
        guard tapContentGestureInfo != nil else { return }
        let tap = NSClickGestureRecognizer(
            target: coordinator,
            action: #selector(Coordinator.handleTapGesture(_:))
        )
        tap.numberOfClicksRequired = tapContentGestureInfo?.count ?? 1
        tap.delegate = coordinator
        scrollView.contentView.addGestureRecognizer(tap)
    }

     func setupPanGesture(for scrollView: NSScrollViewSubclass, coordinator: Coordinator) {
        guard dragContentGestureInfo != nil else { return }
        let pan = NSAutoscrollPanGestureRecognizer(
            target: coordinator,
            action: #selector(Coordinator.handlePanGesture(_:))
        )
        pan.delegate = coordinator
        scrollView.contentView.addGestureRecognizer(pan)
    }
}
//EOF
//AdvancedScrollView+ContinuousGesturePhase.swift
import SwiftUI

public enum ContinuousGesturePhase {
    case possible
    case began
    case changed
    case cancelled
    case ended
}

extension ContinuousGesturePhase {

    init?(_ state: NSGestureRecognizer.State) {
        switch state {
        case .possible:
            self = .possible
        case .began:
            self = .began
        case .changed:
            self = .changed
        case .cancelled, .failed:
            self = .cancelled
        case .ended:
            self = .ended
        default:
            return nil
        }
    }
}

//EOF

//  AdvancedScrollViewProxy.swift
import SwiftUI

public struct AdvancedScrollViewProxy {

    init() {}

    public var contentOffset: CGPoint {
        get { getContentOffset() }
        set { setContentOffset(newValue) }
    }

    public var contentSize: CGSize {
        getContentSize()
    }

    public var contentInset: EdgeInsets {
        get { getContentInset() }
        set { setContentInset(newValue) }
    }

    public var visibleRect: CGRect {
        getVisibleRect()
    }

    // Updated property: Now has both getter and setter.
    public var magnification: CGFloat {
        get { getMagnification() }
        set { setMagnification(newValue) }
    }

    public var isLiveMagnify: Bool {
        getIsLiveMagnify()
    }

    public var isAutoscrollEnabled: Bool {
        get { getIsAutoscrollEnabled() }
        set { setIsAutoscrollEnabled(newValue) }
    }

    // MARK: - Internal Implementation Hooks

    var getContentOffset: (() -> CGPoint)!
    var setContentOffset: ((_ contentOffset: CGPoint) -> Void)!
    var getContentSize: (() -> CGSize)!
    var getContentInset: (() -> EdgeInsets)!
    var setContentInset: ((_ contentInset: EdgeInsets) -> Void)!
    var getVisibleRect: (() -> CGRect)!
    var getScrollerInsets: (() -> EdgeInsets)!
    var getMagnification: (() -> CGFloat)!
    // New setter closure for programmatically setting the magnification.
    var setMagnification: ((_ newMagnification: CGFloat) -> Void)!
    var getIsLiveMagnify: (() -> Bool)!
    var getIsAutoscrollEnabled: (() -> Bool)!
    var setIsAutoscrollEnabled: ((_ isAutoscrollEnabled: Bool) -> Void)!
}

//EOF
